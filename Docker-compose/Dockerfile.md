<!-- 
 *   https://github.com/andreysssr/examples
-->

<!--
# оформление меню
[Заголовки](#headers)  
[Горизонтальные линии](#hr)  
[Выделение текста](#textSelecte)

# оформление заголовков на которые ссылаются меню
<a name="headers"><h2>Заголовки</h2></a>
<a name="hr"><h2>Горизонтальные линии</h2></a>
<a name="textSelecte"><h2>Выделение текста</h2></a>
-->


# Dockerfile

[формат Dockerfile](#format)  
[Замена окружения](#replace-env)  
[.dockerignore](#dockerignore)  
[FROM](#from)  
[RUN](#run)  
[CMD](#cmd)  
[EXPOSE](#expose)  
[ENV](#env)  
[ADD](#add)  
[COPY](#copy)  
[ENTRYPOINT](#entrypoint)  
[VOLUME](#volume)  
[USER](#user)  
[WORKDIR](#workdir)  
[ARG](#arg)  
[ONBUILD](#onbuild)  
[Пример: запуск многострочного скрипта](#more-script)  
[Пример: создание встроенных файлов](#include-file)  

---
<a name="format"><h2>формат Dockerfile</h2></a>
## формат Dockerfile

```
# Comment
INSTRUCTION arguments
```
>Инструкция не чувствительна к регистру. Однако по соглашению они должны быть ЗАГЛАВНЫМИ, чтобы их было легче отличить от аргументов.

- Docker выполняет инструкции по Dockerfile порядку. 
- Dockerfile начинать надо с FROM инструкции. Это может быть после комментариев и глобальных ARG . 
- Docker рассматривает строки, начинающиеся с ` # ` как комментарий,
- Маркер # в любом другом месте строки рассматривается как аргумент. 

```
# Comment
RUN echo 'we are running some # of cool things'
```

>Строки комментариев удаляются перед выполнением инструкций Dockerfile, что означает, что комментарий в следующем примере не обрабатывается оболочкой, выполняющей команду echo, и оба приведенных ниже примера эквивалентны:
```
RUN echo hello \
# comment
world
```
```
RUN echo hello \
world
```

---
<a name="replace-env"><h2>Замена окружения</h2></a>
## Замена окружения

- Переменные среды обозначаются Dockerfile либо с помощью $variable_name, либо ${variable_name}
- синтаксис фигурных скобок обычно используется для решения проблем с именами переменных без пробелов, например ${foo}_bar

Синтаксис ${variable_name}также поддерживает несколько стандартных bash модификаторов:
- ${variable:-word}указывает, что если variable установлено, результатом будет это значение. Если variable не установлено, то word будет результат.
- ${variable:+word}указывает, что если variable установлено, то word будет результатом, иначе результатом будет пустая строка.
- Экранирование возможно путем добавления \ перед переменной: \$fooили \${foo}, например, будет преобразовано в литералы $foo и ${foo} соответственно.
>Во всех случаях word может быть любой строкой, включая дополнительные переменные среды.

Пример (разобранное представление отображается после #):
```
FROM busybox
ENV FOO=/bar
WORKDIR ${FOO}   # WORKDIR /bar
ADD . $FOO       # ADD . /bar
COPY \$FOO /quux # COPY $FOO /quux
```
Переменные среды поддерживаются следующим списком инструкций в Dockerfile:
- ADD
- COPY
- ENV
- EXPOSE
- FROM
- LABEL
- STOPSIGNAL
- USER
- VOLUME
- WORKDIR
- ONBUILD(в сочетании с одной из поддерживаемых выше инструкций)

>Подстановка переменных среды будет использовать одно и то же значение для каждой переменной на протяжении всей инструкции. Другими словами, в этом примере:
```
ENV abc=hello
ENV abc=bye def=$abc
ENV ghi=$abc
```

---
<a name="dockerignore"><h2>.dockerignore</h2></a>
## .dockerignore

пример .dockerignore файла:
```
# comment
*/temp*
*/*/temp*
temp?
```
```
# comment  Игнорируется.
*/temp*    Исключать файлы и каталоги, имена которых начинаются с tempлюбого непосредственного подкаталога корня. Например, простой файл /somedir/temporary.txtисключается, как и каталог /somedir/temp.
*/*/temp*  Исключайте файлы и каталоги, начинающиеся с temp, из любого подкаталога, который находится на два уровня ниже корня. Например, /somedir/subdir/temporary.txtисключается.
temp?      Исключить файлы и каталоги в корневом каталоге, имена которых являются односимвольным расширением temp. Например, /tempaи /tempbисключены.
```

Строки, начинающиеся с !(восклицательный знак), могут использоваться для создания исключений из исключений. Ниже приведен пример .dockerignore файла, использующего этот механизм:
```
*.md
!README.md # Все файлы уценки кроме README.md исключены из контекста.
```

---
<a name="from"><h2>FROM</h2></a>
## FROM

```
FROM [--platform=<platform>] <image> [AS <name>]
FROM [--platform=<platform>] <image>[:<tag>] [AS <name>]
FROM [--platform=<platform>] <image>[@<digest>] [AS <name>]
```

- Инструкция FROM инициализирует новый этап сборки и устанавливает базовый образ для последующих инструкций.
- ARG единственная инструкция, которая может предшествовать FROM в Dockerfile.
- FROM может появляться несколько раз в одном Dockerfile для создания нескольких образов или использования одного этапа сборки в качестве зависимости для другого. 
- При желании можно дать имя новому этапу сборки, добавив AS name в FROM инструкцию. Имя можно использовать в последующих FROM инструкциях COPY --from=<name> для обращения к образу, созданному на этом этапе. 
- Значения tag или digest являются необязательными. 

```
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras
```

- Объявленный ARG перед a FROM находится за пределами стадии сборки, поэтому его нельзя использовать ни в какой инструкции после a FROM. 
- Чтобы использовать значение по умолчанию объявленного ARG перед первым FROM использованием ARG инструкции без значения внутри этапа сборки:

```
ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION
RUN echo $VERSION > image_version
```

---
<a name="run"><h2>RUN </h2></a>
## RUN имеет 2 формы:
- RUN <command>( форма оболочки , команда запускается в оболочке, которая по умолчанию /bin/sh -cв Linux или cmd /S /Cв Windows)
- RUN ["executable", "param1", "param2"]( исполнительная форма)

Инструкция RUN выполнит любые команды в новом слое поверх текущего изображения и зафиксирует результаты. Полученный зафиксированный образ будет использоваться для следующего шага в файле Dockerfile.

---

# RUN --mount позволяет создавать монтирования файловой системы, к которым сборка может получить доступ. Это можно использовать для:

- Создайте привязку к файловой системе хоста или другим этапам сборки.
- Доступ к секретам сборки или сокетам ssh-agent
- Используйте постоянный кеш управления пакетами, чтобы ускорить сборку.

>Синтаксис:--mount=[type=<TYPE>][,option=<value>[,option=<value>]...]
```
Типы маунта

bind(по умолчанию) Контекстные каталоги привязки-монтирования (только для чтения).
cache              Смонтируйте временный каталог для кэширования каталогов для компиляторов и менеджеров пакетов.
secret             Разрешить контейнеру сборки доступ к защищенным файлам, таким как закрытые ключи, без их запекания в образ.
ssh                Разрешить контейнеру сборки доступ к ключам SSH через агенты SSH с поддержкой фраз-паролей.
```

--mount=type=bind
Этот тип монтирования позволяет привязывать файлы или каталоги к контейнеру сборки. Связное монтирование по умолчанию доступно только для чтения.
```
target        Путь монтирования.
source        Исходный путь в from. По умолчанию используется корень from.
from          Имя этапа сборки или образа для корня исходного кода. По умолчанию используется контекст сборки.
rw,readwrite  Разрешить запись на монтирование. Записанные данные будут удалены.
```

--mount=type=cache
Этот тип монтирования позволяет контейнеру сборки кэшировать каталоги для компиляторов и менеджеров пакетов.
```
id           Необязательный идентификатор для идентификации отдельных/разных кэшей. По умолчанию значение target.
target       Путь монтирования.
ro,readonly  Только для чтения, если установлено.
sharing      Один из shared, private, или locked. По умолчанию shared. Кэш shared-монтирование может использоваться одновременно несколькими модулями записи. privateсоздает новое монтирование, если есть несколько писателей. lockedприостанавливает второй писатель, пока первый не отпустит монтирование.
from         Стадия сборки для использования в качестве основы для крепления тайника. По умолчанию пустой каталог.
source       Подпуть в frommount. По умолчанию используется корень from.
mode         Файловый режим для нового каталога кеша в восьмеричном формате. По умолчанию 0755.
uid          Идентификатор пользователя для нового каталога кэша. По умолчанию 0.
gid          Идентификатор группы для нового каталога кэша. По умолчанию 0.
```

Пример: кешировать подходящие пакеты
```Dockerfile
# syntax=docker/dockerfile:1
FROM ubuntu
RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
  --mount=type=cache,target=/var/lib/apt,sharing=locked \
  apt update && apt-get --no-install-recommends install -y gcc
```
--mount=type=secret

```
id        ID секрета. По умолчанию используется базовое имя целевого пути.
target    Путь монтирования. По умолчанию /run/secrets/+ id.
required  Если установлено значение true, инструкция выдает ошибку, когда секрет недоступен. По умолчанию false.
mode      Режим файла для секретного файла в восьмеричном формате. По умолчанию 0400.
uid       ID пользователя для секретного файла. По умолчанию 0.
gid       Идентификатор группы для секретного файла. По умолчанию 0.
```
```
# syntax=docker/dockerfile:1
FROM python:3
RUN pip install awscli
RUN --mount=type=secret,id=aws,target=/root/.aws/credentials \
  aws s3 cp s3://... ...
```

---
<a name="cmd"><h2>CMD</h2></a>
## CMD имеет три формы:
- CMD ["executable","param1","param2"]( форма exec , это предпочтительная форма)
- CMD ["param1","param2"](как параметры по умолчанию для ENTRYPOINT )
- CMD command param1 param2( форма раковины )

```
FROM ubuntu
CMD echo "This is a test." | wc -
```
```
FROM ubuntu
CMD ["/usr/bin/wc","--help"]
```
---
<a name="expose"><h2>EXPOSE</h2></a>
## EXPOSE <port> [<port>/<protocol>...]

>Инструкция EXPOSE информирует Docker о том, что контейнер прослушивает указанные сетевые порты во время выполнения. Вы можете указать, прослушивает ли порт TCP или UDP, и по умолчанию используется TCP, если протокол не указан.
>Инструкция EXPOSE фактически не публикует порт. Он функционирует как тип документации между человеком, который создает образ, и человеком, который запускает контейнер, о том, какие порты предназначены для публикации. 

По умолчанию EXPOSE предполагается TCP. Вы также можете указать UDP:
```
EXPOSE 80/udp

EXPOSE 80/tcp
EXPOSE 80/udp
```

---
<a name="env"><h2>ENV</h2></a>
## ENV

```
# Инструкция ENV устанавливает переменную окружения <key> со значением <value>
ENV <key>=<value> ...
```
```
ENV MY_NAME="John Doe"
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
```
>Переменные среды, установленные с помощью, ENV будут сохраняться при запуске контейнера из полученного образа.  
>Вы можете просмотреть значения с помощью docker inspect, и изменить их с помощью docker run --env <key>=<value>. 

Если переменная среды нужна только во время сборки, а не в финальном образе, рассмотрите возможность вместо этого установить значение для одной команды:
```
RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y ...
```
Или используя ARG, который не сохраняется в финальном изображении:
```
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ...
```

### Альтернативный синтаксис
>Инструкция ENV также допускает альтернативный синтаксис ENV <key> <value>, опуская расширение =

---
<a name="add"><h2>ADD</h2></a>
## ADD имеет две формы:

>Инструкция ADD копирует новые файлы, каталоги или URL-адреса удаленных файлов <src> и добавляет их в файловую систему образа по пути <dest>


```
ADD [--chown=<user>:<group>] [--chmod=<perms>] [--checksum=<checksum>] <src>... <dest>
ADD [--chown=<user>:<group>] [--chmod=<perms>] ["<src>",... "<dest>"]
```
>Примечание
>Сам каталог не копируется, только его содержимое.

>Примечание  
>Функции --chown и --chmod поддерживаются только в файлах Dockerfile, используемых для создания контейнеров Linux, и не будут работать в контейнерах Windows. 

```
ADD hom* /mydir/        # Чтобы добавить все файлы, начинающиеся с «hom»:
ADD hom?.txt /mydir/    # В приведенном ниже примере ?заменяется любым отдельным символом, например, «home.txt».

ADD test.txt relativeDir/ # В приведенном ниже примере используется относительный путь и добавляется «test.txt» в <WORKDIR>/relativeDir/:
ADD test.txt /absoluteDir/ # В то время как в этом примере используется абсолютный путь и добавляется «test.txt» в/absoluteDir/
```
> Все новые файлы и каталоги создаются с UID и GID, равными 0, если только необязательный --chownфлаг не указывает данное имя пользователя, имя группы или комбинацию UID/GID для запроса конкретного владельца добавленного контента. Формат флага --chownдопускает либо строки имени пользователя и имени группы, либо прямое целочисленное значение UID и GID в любой комбинации.
```
ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
ADD --chown=myuser:mygroup --chmod=655 files* /somedir/
```

ADD подчиняется следующим правилам:
- Путь <src>должен быть внутри контекста сборки; вы не можете ADD ../something /something, потому что первым шагом docker buildявляется отправка каталога контекста (и подкаталогов) демону докера.
- Если <src>это URL-адрес и он <dest>не заканчивается косой чертой, то файл загружается с URL-адреса и копируется в <dest>.
- Если <src>это URL-адрес, который <dest>заканчивается косой чертой, то имя файла выводится из URL-адреса, и файл загружается в <dest>/<filename>. Например, ADD http://example.com/foobar /создаст файл /foobar. URL-адрес должен иметь нетривиальный путь, чтобы в этом случае можно было найти подходящее имя файла ( http://example.com не будет работать).
- Если <src>это каталог, копируется все содержимое каталога, включая метаданные файловой системы.
- Если <src>это локальный tar-архив в распознаваемом формате сжатия (identity, gzip, bzip2 или xz), то он распаковывается как каталог. Ресурсы с удаленных URL-адресов не распаковываются. Когда каталог копируется или распаковывается, он ведет себя так же, как и tar -x, результатом является объединение:

---
<a name="copy"><h2>COPY</h2></a>
## COPY имеет две формы:

```
COPY [--chown=<user>:<group>] [--chmod=<perms>] <src>... <dest>
COPY [--chown=<user>:<group>] [--chmod=<perms>] ["<src>",... "<dest>"]
```

```
COPY hom* /mydir/       # Чтобы добавить все файлы, начинающиеся с «hom»:
COPY hom?.txt /mydir/   # В приведенном ниже примере ?заменяется любым отдельным символом, например, «home.txt».

```
> Это <dest>абсолютный путь или путь относительно WORKDIR, в который будет скопирован источник внутри целевого контейнера.
> В приведенном ниже примере используется относительный путь и добавляется «test.txt» в <WORKDIR>/relativeDir/:

```
COPY --chown=55:mygroup files* /somedir/
COPY --chown=bin files* /somedir/
COPY --chown=1 files* /somedir/
COPY --chown=10:11 files* /somedir/
COPY --chown=myuser:mygroup --chmod=644 files* /somedir/
```

>Дополнительно COPY принимает флаг --from=<name>, который можно использовать для установки исходного местоположения на предыдущую стадию сборки (созданную с помощью FROM .. AS <name>), которая будет использоваться вместо контекста сборки, отправленного пользователем. В случае, если этап сборки с указанным именем не может быть найден, вместо него делается попытка использовать образ с таким же именем.

>Примечание
>Сам каталог не копируется, только его содержимое.

COPY подчиняется следующим правилам:
- Путь <src>должен быть внутри контекста сборки; вы не можете COPY ../something /something, потому что первым шагом docker buildявляется отправка каталога контекста (и подкаталогов) демону докера.
- Если <src>это каталог, копируется все содержимое каталога, включая метаданные файловой системы.
- Если <src>это файл любого другого типа, он копируется отдельно вместе с его метаданными. В этом случае, если <dest>заканчивается косой чертой /, он будет считаться каталогом, а содержимое <src>будет записано по адресу <dest>/base(<src>).
- Если указано несколько <src>ресурсов, либо напрямую, либо из-за использования подстановочного знака, то это <dest>должен быть каталог, и он должен заканчиваться косой чертой /.
- Если <dest>он не заканчивается косой чертой, он будет считаться обычным файлом, а содержимое <src>будет записано в <dest>.
- Если <dest>не существует, он создается вместе со всеми отсутствующими каталогами на его пути.

>Примечание
>Первая обнаруженная COPY инструкция сделает кэш недействительным для всех последующих инструкций из Dockerfile, если содержимое файла <src>изменилось. Это включает в себя аннулирование кеша для RUN инструкций.

---
<a name="entrypoint"><h2>ENTRYPOINT</h2></a>
## ENTRYPOINT имеет две формы:
```
# Форма exec , которая является предпочтительной формой:
ENTRYPOINT ["executable", "param1", "param2"]

# Форма оболочки :
ENTRYPOINT command param1 param2
```
---
<a name="volume"><h2>VOLUME</h2></a>
## VOLUME ["/data"]

```
VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]
```

---
<a name="user"><h2>USER</h2></a>
## USER <user>[:<group>]

>Инструкция USER устанавливает имя пользователя (или UID) и, возможно, группу пользователей (или GID), которые будут использоваться в качестве пользователя и группы по умолчанию для оставшейся части текущего этапа.

```
USER <user>[:<group>]
USER <UID>[:<GID>]
```

---
<a name="workdir"><h2>WORKDIR</h2></a>
## WORKDIR /path/to/workdir

>Инструкция WORKDIR устанавливает рабочий каталог для любых RUN, CMD, и инструкций ENTRYPOINT, которые следуют за ней в файле . Если не существует, он будет создан, даже если он не используется ни в одной последующей инструкции.COPY ADD Dockerfile WORKDIR Dockerfile

>Инструкцию WORKDIR можно использовать несколько раз в файле Dockerfile. Если указан относительный путь, он будет относиться к пути предыдущей WORKDIR инструкции. Например:

```
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd

# Вывод последней pwdкоманды в этом случае Dockerfile будет /a/b/c.
```

>Инструкция WORKDIR может разрешать переменные среды, ранее установленные с помощью ENV. Вы можете использовать только переменные среды, явно заданные в файле Dockerfile. Например:
```
ENV DIRPATH=/path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd

# Вывод последней pwdкоманды в этом Dockerfile будет /path/$DIRNAME
```

>Если не указано, рабочим каталогом по умолчанию является ` / `

---
<a name="arg"><h2>ARG</h2></a>
## ARG <name>[=<default value>]

>Инструкция ARG определяет переменную, которую пользователи могут передать во время сборки компоновщику с помощью docker build команды, использующей --build-arg <varname>=<value>

Значения по умолчанию
Инструкция ARG может дополнительно включать значение по умолчанию:

```
FROM busybox
ARG user1=someuser
ARG buildno=1
# ...
```

>Инструкция ARG выходит за рамки в конце этапа сборки, на котором она была определена. Чтобы использовать аргумент на нескольких этапах, каждый этап должен включать инструкцию ARG
```
FROM busybox
ARG SETTINGS
RUN ./run/setup $SETTINGS

FROM busybox
ARG SETTINGS
RUN ./run/other $SETTINGS
```

### Использование переменных ARG
>Вы можете использовать инструкцию ARG или ENV для указания переменных, доступных для RUN инструкции.  
>Переменные среды, определенные с помощью ENV инструкции, всегда переопределяют ARG инструкцию с тем же именем. 

```
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=v1.0.0
RUN echo $CONT_IMG_VER
```
Затем предположим, что этот образ создан с помощью этой команды:
```
docker build --build-arg CONT_IMG_VER=v2.0.1 .
```
В этом случае RUN инструкция использует v1.0.0 вместо ARG параметра.

с другой ENV спецификацией, вы можете создать более полезные взаимодействия между ARG и ENV инструкциями:

```
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0}
RUN echo $CONT_IMG_VER
```
В отличие от ARG инструкции, ENV значения всегда сохраняются в построенном образе. Рассмотрим сборку докера без --build-arg флага:

```
docker build .

# CONT_IMG_VER он по-прежнему сохраняется в образе, но его значение будет v1.0.0
```
>Техника раскрытия переменных в этом примере позволяет передавать аргументы из командной строки и сохранять их в конечном образе, используя инструкцию ENV

---
<a name="onbuild"><h2>ONBUILD</h2></a>
## ONBUILD <INSTRUCTION>

>Эта ONBUILD инструкция добавляет к образу триггерную инструкцию, которая будет выполняться позднее, когда образ будет использоваться в качестве основы для другой сборки. Триггер будет выполняться в контексте нижестоящей сборки, как если бы он был вставлен сразу после инструкции FROM в нижестоящем Dockerfile
>- Любая инструкция сборки может быть зарегистрирована как триггер.

Вот как это работает:
- Когда он встречает ONBUILD инструкцию, сборщик добавляет триггер к метаданным создаваемого образа. Инструкция никак иначе не влияет на текущую сборку.
- В конце сборки список всех триггеров сохраняется в манифесте образа под ключом OnBuild. Их можно проверить с помощью docker inspectкоманды.
- В дальнейшем образ можно использовать как основу для новой сборки, воспользовавшись инструкцией FROM. В рамках обработки FROMинструкции нижестоящий построитель ищет ONBUILDтриггеры и выполняет их в том же порядке, в котором они были зарегистрированы. Если какой-либо из триггеров выходит из строя, FROMинструкция прерывается, что, в свою очередь, приводит к сбою сборки. Если все триггеры выполняются успешно, FROMинструкция завершается, и сборка продолжается в обычном режиме.
- Триггеры очищаются от окончательного изображения после выполнения. Другими словами, они не наследуются «внучатскими» сборками.

Например, вы можете добавить что-то вроде этого:
```
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
```

---
<a name="more-script"><h2>Пример: запуск многострочного скрипта</h2></a>
## Пример: запуск многострочного скрипта

```
# syntax=docker/dockerfile:1
FROM debian
RUN <<EOT bash
  apt-get update
  apt-get install -y vim
EOT
```

```
# syntax=docker/dockerfile:1
FROM debian
RUN <<EOT
  mkdir -p foo/bar
EOT
```

```
# syntax=docker/dockerfile:1
FROM python:3.6
RUN <<EOT
#!/usr/bin/env python
print("hello world")
EOT
```

```
# syntax=docker/dockerfile:1
FROM alpine
RUN <<FILE1 cat > file1 && <<FILE2 cat > file2
I am
first
FILE1
I am
second
FILE2
```
---
<a name="include-file"><h2>Пример: создание встроенных файлов</h2></a>
## Пример: создание встроенных файлов

>В COPY командах исходные параметры можно заменить индикаторами here-doc. Применяются обычные правила раскрытия переменных здесь-doc и удаления вкладок .
```
# syntax=docker/dockerfile:1
FROM alpine
ARG FOO=bar
COPY <<-EOT /app/foo
	hello ${FOO}
EOT
```

```
# syntax=docker/dockerfile:1
FROM alpine
COPY <<-"EOT" /app/script.sh
	echo hello ${FOO}
EOT
RUN FOO=abc ash /app/script.sh
```
