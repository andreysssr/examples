<!-- 
 *   https://github.com/andreysssr/examples

 *   http://linux.yaroslavl.ru/docs/prog/gnu_make_3-79_russian_manual.html
-->

# Makefile

[Имена make-файлов](#makefile)  
[Как выглядят правила (rules)](#rules)  
[Пример простого make-файла](#example_makefile)  
[Как make обрабатывает make-файл](#run_makefile)  
[Упрощение make-файла с помощью переменных](#variables)  
[Правило для очистки каталога](#clean_dir)  
[Создание make-файлов](#create_makefile)  
[Подключение других make-файлов](#include)  
[Переменная MAKEFILES](#variable_MAKEFILES)  
[Как make читает make-файл](#read_makefile)  
[Присваивание значения переменным](#set_variables)  
[Условные конструкции](#if)  
[Определения правил](#set_rules)  
[Составление правил (rules)](#create_rules)  
[Синтаксис правил](#syntax_rules)  
[Использование шаблонных символов в именах файлов](#template_characters_to_name)  
[Примеры шаблонных имен](#example_template_characters)  
[Абстрактные цели (phony targets)](#abstract_target)  
[Имена специальных целей](#name_special_target)  
[Несколько правил с одной целью](#several_rules_to_target)  
[Написание команд](#write_commands)  
[Отображение исполняемых команд (command echoing)](#show_commands)  
[Исполнение команд](#execute_commands)  
[Установка интерпретатора командной строки](#set_shell)  
[Ошибки при исполнении команд](#errors_execute)  
[Использование переменных (variables)](#using_variables)  
[Обращение к переменным](#call_variables)  
[Две разновидности (flavors) переменных](#varieties_variables)  
[Добавление текста к переменной](#add_text_to_variables)  
[Директива override](#override)  
[Многострочные переменные](#many_string_variables)  
[Переменные из операционного окружения (environment)](#variables_environment)  
[Условные части make-файла](#if_parts_makefile)  
[Функция foreach](#function_foreach)  
[Перекрытие" (overriding) переменных](#overriding)  
[Обзор опций](#optionns)  

<a name="makefile"><h2>Имена make-файлов</h2></a>

По умолчанию, когда `make` ищет make-файл для обработки, она поочередно пробует найти файлы со следующими именами (в указанном порядке): `makefile` и `Makefile`.

Если вы хотите использовать "нестандартное" имя для вашего make-файла, вы можете указать его в командной строке, используя опции `-f` или `--file`. Аргументы `-f имя_файла` или `--file=имя_файла`, указывают программе make на необходимость использования файла с именем имя_файла в качестве make-файла. 

- Вы можете задать обработку сразу нескольких make-файлов, перечислив их в командной строке с помощью нескольких опций `-f` или `--file`. 
- Все указанные таким образом make-файлы логически "объединяются" в том порядке, как они были заданы в командной строке. 
- При наличии в командной строке опций `-f` или `--file`, автоматического поиска make-файлов с именами `makefile` и `Makefile`, не производится.

```bash
make -f Makefile1 -f Makefile2 

make --file=Makefile1 --file=Makefile2 
```

---
<a name="rules"><h2>Как выглядят правила (rules)</h2></a>

Простой make-файл состоит из "правил" (rules) следующего вида:

```
цель ... : пререквизит ...
        команда
        команда
        ...
```

- `Цель (target)` представляет собой название группы команд, либо целей, либо целей и команд
- `Пререквизит` (prerequisite) - могут выступать другие цели
- `Команда` - это действие, выполняемое утилитой make. Это строка которую мы обычно пишем в bash терминале. 

- В одной цели могут использоваться несколько команд 
- Каждая команда прописывается на новой строке.

> Важное замечание: строки, содержащие команды обязательно должны начинаться с символа табуляции!  
Это - "грабли", на которые наступают многие начинающие пользователи.

Для повышения удобочитаемости, длинные строки можно переносить на следующую строку с помощью символа обратной косой черты ` \ `, за которым следует перевод строки.  

После обратной черты не должно идти символов пробела.

```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
        
clean :
        -rm edit $(objects)
```

---
<a name="example_makefile"><h2>Пример простого make-файла</h2></a>

```
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```
> Для повышения удобочитаемости, длинные строки разбиты на две части с помощью символа обратной косой черты, за которым следует перевод строки.

Для того, чтобы с помощью этого make-файла создать исполняемый файл `edit', наберите:
```
make
```

Для того, чтобы удалить исполняемый и объектные файлы из директории проекта, наберите:
```
make clean
```

---

<a name="run_makefile"><h2>Как make обрабатывает make-файл</h2></a>

По умолчанию, make начинает свою работу с первой встреченной цели (кроме целей, чье имя начинается с символа `.')  

Эта цель будет являться главной целью по умолчанию (default goal). Главная цель (goal) - это цель, которую стремится достичь make в качестве результата своей работы. 

В примере из предыдущего раздела, главная цель заключалась в обновлении исполняемого файла `edit', поэтому мы поместили данное правило в начало make-файла.

Таким образом, когда вы даете команду:
```
make
```
`make` читает make-файл из текущей директории и начинает его обработку с первого встреченного правила.

Другие правила обрабатывается потому, что их цели прямо или косвенно являются пререквизитами для главной цели. 

Если какое-либо правило никоим образом не "связано" с главной целью (то есть ни прямо, ни косвенно не являются его пререквизитом), то это правило не обрабатывается.  

Чтобы задействовать такие правила, придется явно указать make на необходимость их обработки (подобным, например, образом: `make clean`).

<a name="variables"><h2>Упрощение make-файла с помощью переменных</h2></a>

Обычной практикой при построении make-файлов является использование переменных.

`Переменные (variables)` позволяют, один раз определив текстовую строку, затем использовать ее многократно в нужных местах.

```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
```

Далее, всякий раз, когда нам нужен будет список объектных файлов, мы можем использовать значение этой переменной с помощью записи `$(objects)'

```
edit : $(objects)
    cc -o edit $(objects)
        
clean :
    rm edit $(objects)       
```

<a name="clean_dir"><h2>Правило для очистки каталога</h2></a>

Часто, в make-файле указывается, каким образом можно выполнить некоторые действия. Таким действием, например, может быть удаление все объектных и исполняемых файлов программы для очистки каталога.

Вот как можно было бы написать правило для очистки каталога в нашем проекте текстового редактора:
```
clean:
    rm edit $(objects)
```
На практике, скорее всего, мы бы записали это правило чуть более сложным способом, предполагающим возможность непредвиденных ситуаций:
```
.PHONY : clean
clean :
    -rm edit $(objects)
```
> Такая запись предотвратит возможную путаницу если, вдруг, в каталоге будет находится файл с именем `clean`, а также позволит make продолжить работу, даже если команда rm завершится с ошибкой.

Подобное правило не следует помещать в начало make-файла, поскольку мы не хотим, чтобы оно запускалось "по умолчанию"! В нашем примере, мы помещаем данное правило в конец make-файла, чтобы главной целью по умолчанию оставалась сборка файла edit.

Поскольку `clean` не является пререквизитом цели edit, это правило не будеть выполняться, если вызывать `make` без аргументов. Для запуска данного правила, нужно будет набрать 
```
make clean.
```

---

<a name="create_makefile"><h2>Создание make-файлов</h2></a>

> Make-файл является хранилищем информации, указывающей программе make, каким образом нужно перекомпилировать проект.

### Из чего состоят make-файлы

> Make-файл может состоять из конструкций пяти видов: `явные правила`, `неявные правила`, `определения переменных`, `директивы` и `комментарии`. Правила, переменные и директивы подробно рассматриваются в следующих главах.

- `Явное правило` (explicit rule) описывает, когда и каким образом следует обновлять файлы, называемые целями правила. В этом правиле перечисляются файлы, от которых зависит цель правила (так называемые пререквизиты), а также могут быть заданы команды, которые следует использовать для создания или обновления цели. 

- `Неявное правило` (implicit rule) описывает, когда и каким образом нужно обновлять некоторую группу файлов, имена которых подходят под определенный шаблон. Такое правило описывает, как цель может зависеть от файла со "сходным" именем и задает команды для обновления целей.

- `Определение переменной` (variable definition) - это строка make-файла, в которой переменной присваивается определенное текстовое значение. Далее, это значение может быть "подставлено" в нужном месте текста. В нашем примере make-файла, переменная `objects` определялась как список объектных файлов программы.

- `Директива` указывает программе make на необходимость произведения некоторого специального действия во время чтения make-файла. Возможны, в частности, следующие действия:
  - Чтение другого make-файла.
  - Решение (на основе значения переменных) об использовании или игнорировании части make-файла.
  - Определение многострочной переменной, состоящей из нескольких строк.
- `Комментарий` - символ `#` обозначает начало комментария. Весь текст, начиная с этого символа и до конца строки, будет игнорирован.

---

<a name="include"><h2>Подключение других make-файлов</h2></a>

> Встретив в make-файле директиву `include`, make приостанавливает чтение текущего make-файла и, прежде чем продолжить работу, прочитывает один или несколько указанных в этой директиве make-файлов. Эта директива представляет собой строку make-файла, выглядящую подобным образом:

```
include имена_файлов...
```

Имена файлов могут представлять собой шаблоны имен, допустимые в интерпретаторе командной строки.

- В начале строки могут находится дополнительные пробелы - все они будут игнорированы. 
- Наличие символа табуляции в начале строки недопустимо, поскольку такие строки make считает командами. 
- Между словом `include` и началом списка файлов, а также между именами файлов необходим пробел. Лишние пробелы между именами, а также пробелы после конца директивы, игнорируются.

Если, например, у вас есть три файла с расширением `.mk` - `a.mk`, `b.mk`, и `c.mk`, а переменная `$(bar)` ссылается на строку `bish bash`, то следующая запись

```
include foo *.mk $(bar)
```
будет эквивалентна
```
include foo a.mk b.mk c.mk bish bash
```
```
include .env
```

> Когда make обрабатывает директиву `include`, она приостанавливает чтение текущего make-файла и поочередно читает каждый файл из списка, указанного в директиве. Когда весь список будет прочитан, make возвращается к обработке make-файла, в котором была встречена директива `include`.

Директива `include` может оказаться полезной если, предположим, у нас имеется несколько программ, собираемых при помощи отдельных make-файлов, которым требуется наличие некоторого "общего" набора определений переменных

Другой случай, когда директива `include` может быть использована - это автоматическая генерация `пререквизиттов` для исходных файлов. Автоматически сгенерированные `пререквизиты` могут быть помещены в отдельный файл, который, затем, будет включаться в основной make-файл программы. Подобная практика, в целом, выглядит более привлекательной, чем "беспорядочное" добавление новых `пререквизитов` в конец главного make-файла

> Если указанное в директиве имя начинается не с символа `/` и файл с таким именем отсутствует в текущей директории, производится его поиск еще в нескольких каталогах. 
- Сначала поиск производится во всех каталогах, которые были указаны в командной строке с помощью опций `-I` и `--include-dir`. 
- Затем, поиск производится поочередно в следующих директориях (если, конечно, они существуют): `/usr/local/include`, `/usr/gnu/include`, `/usr/local/include`, `/usr/include`.

Если поиск включаемого make-файла завершился неудачно, make выдает предупреждающее сообщение, которое, однако не является фатальной ошибкой, поскольку обработка make-файла, содержащего директиву include, еще продолжается.

---
<a name="variable_MAKEFILES"><h2>Переменная MAKEFILES</h2></a>

>Если среди переменных среды `(environment variables)` имеется переменная с именем `MAKEFILES`, то ее содержимое интерпретируется как список имен `(разделенных пробелами)` дополнительных make-файлов, которые должны быть прочитаны перед тем, как начнут обрабатываться "основные" make-файлы. 

> Этот механизм работает во многом аналогично директиве `include`. Аналогичным образом производится и поиск этих дополнительных make-файлов в разных каталогах. При этом, главная цель не может браться из этих файлов, а отсутствие какого-либо из них не рассматривается как ошибка.

---

<a name="read_makefile"><h2>Как make читает make-файл</h2></a>

Программа GNU make работает по двухпроходной схеме. На первом проходе производится чтение всех make-файлов (в том числе и подключаемых), в ходе которого вся содержащаяся в них информация (переменные и их значения, явные и неявные правила) переводится во внутреннее представление и строится граф зависимостей для всех целей и их пререквизитов. Далее, на втором проходе, это внутреннее представление используется для определения того, какие именно цели нуждаются в обновлении и исполняются соответствующие правила.

Понимание такой двухпроходной схемы является важным, поскольку она оказывает непосредственное влияние на ход вычисления переменных и функций;

<a name="set_variables"><h2>Присваивание значения переменным</h2></a>

Определения переменных обрабатываются следующим образом:
```
немедленно = отложенно
немедленно ?= отложенно
немедленно := немедленно
немедленно += отложенно или немедленно

define немедленно
    отложенно
endef
```

В операторе добавления, `+=', правая часть обрабатывается "немедленно", если переменная была ранее определена как упрощенно вычисляемая (с помощью `:=') и "отложенно" в противном случае.

<a name="if"><h2>Условные конструкции</h2></a>

Все условные конструкции (во всех формах - ifdef, ifeq, ifndef и ifneq) целиком и полностью обрабатываются "немедленно".

<a name="set_rules"><h2>Определения правил</h2></a>

Правила всегда обрабатываются одинаковым образом, независимо от их формы:

```
немедленно : немедленно ; отложенно
    отложенно
```
То есть, разделы целей и пререквизитов обрабатываются немедленно, а обработка команд, используемых для обновления цели, всегда откладывается. Это общее правило действует для явных правил, шаблонных правил, суффиксных правил, статических шаблонных правил и простом определении пререквизитов.

--- 
<a name="create_rules"><h2>Составление правил (rules)</h2></a>

Правила (rules) содержатся в make-файле и описывают, когда и каким образом должны быть исполнены, называемые целями (targets).  
Чаще всего, каждое правило содержит только одну цель. 

Порядок следования правил внутри make-файле не имеет значения.

Исключение составляет лишь выбор главной цели по умолчанию (default goal) - цели, к которой стремиться make, если вы не задали ее явно. 

По умолчанию, главной целью становиться цель из первого правила в первом обрабатываемом make-файле. Если это правило содержит несколько целей, то только первая из них становится главной целью. 

Здесь есть два исключения. Во-первых, главными целями, выбираемыми по умолчанию, не могут стать цели, имя которых начинается с точки (если только они не содержат по крайней мере одного символа `/'). И, во-вторых, из процесса выбора главной цели исключаются шаблонные правила

Поэтому, мы обычно пишем make-файлы таким образом, чтобы первое правило описывало процесс сборки готовой программы, или всех программ, описываемых в этом make-файле (часто, для этого используется цель с именем `all').

---
<a name="syntax_rules"><h2>Синтаксис правил</h2></a>

В общем виде, правило выглядит так:

```
цели : пререквизиты
    команда
    ...
```
или так:
```
цели : пререквизиты ; команда
    команда
    ...
```

> Обычно, в правиле содержится только одна цель, однако, иногда имеет смысл задать несколько целей в одном правиле

> Строки, содержащие команды, должны начинаться с символа табуляции. Первая команда может располагаться либо в строке с пререквизитами (и отделяться от них точкой с запятой), либо в следующей строке после пререквизитов (эта строка должна начинаться с символа табуляции). В обоих случаях, результат будет один и тот же.

Поскольку знак доллара используется для ссылки на переменные, для использования его в правилах, нужно писать `$$'

Длинные строки make-файла могут быть разделены на части с помощью символа '\', находящегося в конце строки. Это может повысить удобочитаемость make-файла, но "технической" необходимости в этом нет - make никак не ограничивает длину строк make-файла.

---

<a name="template_characters_to_name"><h2>Использование шаблонных символов в именах файлов</h2></a>

При использованием шаблонных символов, с помощью одного имени можно задать целую группу файлов. В make шаблонными символами являются `*`, `?` и `[...]`. Например, шаблон `*.c` будет соответствовать всем файлам с суффиксом `.c`, находящимся в текущей директории.

Символ `~` в начале имени файла, также имеет специальное значение. Одиночный символ `~` или сочетание `~/` означает ваш домашний каталог. Например, выражение `~/bin` будет означать `/home/you/bin`. Если сразу за символом `~` следует некоторое имя, такая строка будет представлять собой домашнюю директорию пользователя с этим именем. Например, строка `~john/bin` будет означать `/home/john/bin`. 

Специальное значение шаблонных символов может быть "отключено" с помощью предшествующего им символа `\ `. Таким образом, строка `foo\*bar` будет ссылаться на довольно странное имя, состоящее из семи символов - `foo*bar`.

---

<a name="example_template_characters"><h2>Примеры шаблонных имен</h2></a>

Шаблонные имена могут быть использованы в командах, которые содержатся в правилах. Такие имена будут "раскрыты" интерпретатором командной строки. Вот пример правила для удаления всех объектных файлов из текущей директории:
```
clean:
    rm -f *.o
```

Шаблоны также могут быть полезны в качестве пререквизитов правил. В следующем примере, команда `make print' вызовет печать всех файлов с исходными текстами (файлов с расширением `.c'), которые были модефицированы с тех пор, как вы последний раз распечатывали их подобным образом:
```
print: *.c
    lpr -p $?
    touch print
```
В данном правиле, цель `print` является пустой целью (empty target file); смотрите раздел Использование пустых целей для фиксации событий. Автоматичесая переменная `$?` используется для печати только тех пререквизитов, которые были изменены (смотрите раздел Автоматические переменные.)

При задании переменной, раскрытия шаблонов не производится. Например, если вы запишите:
```    
objects = *.o
```

то значением переменной objects будет строка `*.o`. Однако, если вы используете значение переменной objects в цели, в пререквизите или в команде, то в момент использования шаблона, будет произведено его расширение. Чтобы присвоить переменной objects значение, полученное после расширения шаблона, используйте функцию wildcard:
```
objects := $(wildcard *.o)
```

---

<a name="abstract_target"><h2>Абстрактные цели (phony targets)</h2></a>

Абстрактная цель (phony target) - это цель, которая не является, на самом деле, именем файла. Это - просто имя для некоторой последовательности команд, которую при необходимости может выполнить make.

```
clean:
    rm *.o temp
```
команда rm будет выполняться всякий раз, когда вы скажете `make clean`.

Однако, правило с такой "псевдо-целью" откажется работать, если в текущем каталоге по какой-нибудь причине окажется файл с именем `clean`. 

Поскольку в правиле не указано каких-либо пререквизитов, файл `clean` всегда будет считаться "новым" и команды, указанные в правиле никогда не выполнятся. Во избежании подобной проблемы, вы можете прямо указать, что некоторая цель является абстрактной. Для этого используется специальная цель `.PHONY`

```
.PHONY : clean
```
После этого, вызов `make clean` будет приводить к исполнению нужных команд, независимо от того, существует файл `clean` или нет.

Таким образом, сначала должна идти строка, объявляющая `clean` абстрактной целью, а затем уже следует правило, описывающее эту цель:

```
.PHONY: clean
clean:
    rm *.o temp
```

Абстрактные цели могут иметь пререквизиты. Например, когда в одном каталоге содержится сразу несколько собираемых программ, удобно хранить их описания в одном make-файле. Так как главной целью по умолчанию становится первая цель из make-файла, в таких случаях, обычно, первым правилом make-файла делают правило с абстрактной целью `all`, пререквизитами которой являются все собираемые программы. Например:

```
all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

prog2 : prog2.o
        cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
```

Теперь вам достаточно сказать `make`, чтобы обновить все три программы, или указать нужные аргументы для обновления конкретных программ (например, `make prog1 prog3`).


Когда одна абстрактная цель является пререквизитом другой абстрактной цели, она работает как своего рода "подпрограмма". В следующем примере, `make cleanall` удалит объектные файлы, diff-файлы, и файл `program`:

```
.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
    rm program

cleanobj :
    rm *.o

cleandiff :
    rm *.diff
```

---

<a name="name_special_target"><h2>Имена специальных целей</h2></a>

- `.PHONY`
Пререквизиты специальной цели `.PHONY` объявляются абстрактными целями. При необходимости обновления таких целей, make будет выполнять команды "безусловно", независимо от того, существует ли файл с таким именем, и времени, когда он был модефицирован.

- `.DEFAULT`
Команды, определенные для цели `.DEFAULT`, будут использованы со всеми целями make-файла, для которых не найдено ни явных, ни неявных правил.  
Команды, определенные для `.DEFAULT`, будут использованы для всех пререквизитов, не являющихся целями каких-либо правил.

- `.SILENT`
Если вы указали некоторые цели в качестве пререквизитов `.SILENT`, то в процессе обновления этих целей, make не будет печатать выполняемые при этом команды. Указываемые для `.SILENT` команды не имеют значения. 
  - В случае использования `.SILENT` без списка пререквизитов, будет отключена печать всех исполняемых команд. Такое использование `.SILENT` поддерживается только по историческим причинам, для обеспечения совместимости. 

> Рекомендуеся использовать более избирательный метод для подавления печати отдельных команд. Временно подавить печать исполняемых команд можно, запуская `make` с опциями `-s` или `--silent`

---

<a name="several_rules_to_target"><h2>Несколько правил с одной целью</h2></a>

```
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
```

---

<a name="write_commands"><h2>Написание команд</h2></a>

- Определенные в правиле команды, представляют собой текстовые строки с командами для интерпретатора командной строки. 
- Команды эти исполняются последовательно, одна за другой. 
- Каждая строка, содержащая команду, должна начинаться с символа табуляции. 
- Первая команда также может быть расположена в строке правила, содержащей список целей и пререквизитов - в таком случае она отделяется от списка пререквизитов символом точки с запятой и не требует наличия символа табуляции в ее начале. 
- Среди строк, содержащих команды, могут присутствовать пустые строки и строки, содержащие лишь комментарии - все они будут проигнорированы. 

---
<a name="show_commands"><h2>Отображение исполняемых команд (command echoing)</h2></a>

Обычно, `make` печатает каждую командную строку перед тем, как она будет выполнена.
Такой механизм называется эхом (echoing), поскольку он создает впечатление, что это вы сами набираете исполняемые команды.

Если строка, содержащая команду, начинается с символа `@`, печать этой команды не производится. Символ `@` удаляется из строки с командой перед тем, как она передается для обработки интерпретатору командной строки. 
```
@echo About to make distribution files
```
Когда `make` вызывается с опцией `-n` или `--just-print`, происходит только лишь отображение команд, без их реального выполнения. Смотрите раздел Обзор опций. 

Это единственный случай, когда команды, начинающиеся с символа `@`, также будут напечатаны. Используя эти опции, можно увидеть, какие команды make считает необходимым выполнить, без того, чтобы реально их выполнять.

- Опции `-s` и `--silent` отключают всякое отображение команд, как если бы все команды начинались с символа `@`. 
- Использование в make-файле правила со специальной целью `.SILENT` без указания пререквизитов, имеет аналогичный эффект. Использование специальной цели `.SILENT` является устаревшей практикой, взамен которой мы рекомедуем пользоваться более гибким механизмом - символом `@`.

---

<a name="execute_commands"><h2>Исполнение команд</h2></a>

Последовательность команд, обновляющих цель, исполняется путем вызова отдельного экземпляра интерпретатора командной строки для каждой из строк make-файла, содержащих команды.

Это, означает, что (обратите внимание!) такие команды, как `cd`, влияющие на переменные среды процесса, не окажут никакого влияния на следующие за ними команды.

Если вы хотите, чтобы команда `cd` повлияла на следующую за ней команду, поместите обе команды на одну строку make-файла, отделив друг от друга с помощью точки с запятой - `;`. В таком случае, make будет рассматривать их как единую команду и "вместе" передаст их интерпретатору командной строки для последовательного выполнения. 

```
foo : bar/lose
    cd bar; gobble lose > ../foo
```
---

<a name="set_shell"><h2>Установка интерпретатора командной строки </h2></a>

> Имя программы, являющейся интерпретатором командной строки, берется из переменной `SHELL`. По умолчанию, используется программа `/bin/sh`.

```
# поменять интерпретатор командрной строки на (bash)
SHELL = /bin/bash
```

Для повышения удобочитаемости, вы можете разбить длинные строки с командами на несколько частей с помощью символа '\'. Его нужно поместить в конец каждой строки-фрагмента, за исключением последней. Перед вызовом интерпретатора командной строки, подобная последовательность строк будет скомбинирована в одну строку, путем удаления конечных символов '\'. Таким образом, предыдущий пример можно записать так:

```
foo : bar/lose
    cd bar;  \
    gobble lose > ../foo
```

Имя программы, являющейся интерпретатором командной строки, берется из переменной `SHELL`. По умолчанию, используется программа `/bin/sh`.

--- 

<a name="errors_execute"><h2>Ошибки при исполнении команд</h2></a>

После завершения очередной команды, make проверяет полученный от нее код возврата. В случае успешного ее завершения, выполняется (своим экземпляром командного интерпретатора) следующая командная строка; после выполнения последней команды, обработка правила считается завершенной.

Если во время выполнения команды произошла ошибка (от нее был получен ненулевой код возврата), make прекращает обработку текущего правила, и, возможно, прерывает работу.

В определенных ситуациях, ошибка при выполнении некоторой команды не является проблемой. Например, вы можете использовать команду mkdir, дабы быть уверенным в существовании некоторого каталога. Если такая директория уже существует, команда mkdir сообщит об ошибке, но, скорее всего, вы захотите, чтобы make в таком случае продолжила работу, не обращая внимания на ошибку.

> Для того, чтобы проигнорировать ошибки в команде, поместите в начало строки (после символа табуляции), где она описана, символ `-`. 
>> Перед тем, как эта команда будет передана интерпретатору командной строки, символ `-` будет из нее удален.

Игнорирование ошибок в команде:
```
clean:
    -rm -f *.o
```
обработка make-файла не будет прервана даже в том случае, если команда `rm` не сможет удалить файл.

При запуске make с опцией `-i` или `--ignore-errors`, будут игнорироваться ошибки во всех командах, любого из правил. Такой же эффект достигается при изпользовании специальной цели `.IGNORE` в правиле, не имеющем пререквизитов. Вместо подобной устаревшей практики, рекомендуется применять более гибкую методику с использованием `-`.

```
mkdir:
    -mkdir test
```
или
```
make -i mkdir
```

---

<a name="using_variables"><h2>Использование переменных (variables)</h2></a>

`Переменная (variable)` представляет собой имя, определенное в make-файле для представления строки текста, называемой значением переменной. Далее, по вашему запросу, эти значения могут быть подставлены в нужные места make-файла (например, в имена целей, имена пререквизитов, команды и так далее).

Переменная может представлять собой что угодно, например, список файлов, набор передаваемых компилятору опций, имя запускаемой программы, список каталогов с исходными файлами, директорию для выходных файлов и так далее.

Имена переменных чувствительны к регистру. Таким образом, имена `foo', `FOO', и `Foo' будут ссылаться на разные переменные.

Традиционно, имена переменных записывались с использованием букв верхнего регистра.

---
<a name="call_variables"><h2>Обращение к переменным</h2></a>

Для подстановки значения переменной, напишите знак доллара, за которым следует имя переменной, заключенное в круглые или фигурные скобки: обе записи `$(foo)` и `${foo}` представляют собой ссылку на переменную `foo`.

```
foo = c
```
Пробелы, находящиеся в операторе присваивания перед новым значеним переменной, игнорируются, поэтому переменная foo будет содержать строку `c`

---
<a name="varieties_variables"><h2>Две разновидности (flavors) переменных</h2></a>

>Присваивание-переменной может быть любой допустимой формой оператора присваивания:
>- рекурсивной (`=`), 
>- статической (`:=`), 
>- дополняющей (`+=`),
>- условной (`?=`).


- Первая разновидность - это рекурсивно вычисляемые (recursively expanded) переменные. Такие переменные определяются с помощью `=`
- Упрощенно вычисляемые (simply expanded) переменные определяются с помощью `:=`
- Условного присваивания, поскольку срабатывает лишь в том случае, когда переменная еще не была определена, определяются с помощью `?=`

```
# 1 Рекурсивно вычисляемые      |
--------------------------------
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)
```
Выдаст на экран `Huh?`: при вычислении ссылки `$(foo)`, она будет заменена на `$(bar)`, которая, свою очередь, заменена на `$(ugh)`, которая, наконец, будет расширена в `Huh?`.


>  При ссылке на упрощенно вычисляемую переменную делается простая подстановка ее значения (без каких-либо дополнительных вычислений).
```
# 2 Упрощенно вычисляемые      |
--------------------------------
x := foo
y := $(x) bar
x := later
```
эквивалентно
```
y := foo bar
x := later
```

```
# 3 Условного присваивания      |
--------------------------------
FOO ?= bar
```
эквивалентно
```
ifeq ($(origin FOO), undefined)
  FOO = bar
endif
```

---

<a name="add_text_to_variables"><h2>Добавление текста к переменной</h2></a>

Часто возникает необходимость добавить некоторый текст к значению уже определенной переменной. Вы можете это сделать с помощью оператора `+=`, например:
```
objects += another.o
```

Здесь, к значению переменной `objects` добавляется текст `another.o` (предваренный одиночным пробелом). Так, в результате выполнения фрагмента:
```
objects = main.o foo.o bar.o utils.o
objects += another.o
```
Переменная `objects` получит значение `main.o foo.o bar.o utils.o another.o`.

Примерный аналог этого фрагмента без использования `+=` может выглядеть так:
```
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
```
```
variable := value
variable += more
```
эквивалентен следующему:
```
variable := value
variable := $(variable) more
```
<br>

```
variable = value
variable += more
```
примерно эквивалентен:
```
temp = value
variable = $(temp) more
```
---
<a name="override"><h2>Директива override</h2></a>

Если переменная была установлена при помощи командной строки (смотрите раздел "Перекрытие" переменных), то "обычное" присваивание ей нового значения внутри make-файла игнорируется. Если вы все-таки хотите присвоить подобной переменной новое значение, нужно использовать директиву override, выглядящую следующим образом:

```
override переменная = значение
```
или
```
override переменная := значение
```
При добавлении текста к переменной, определенной через командную строку, используйте конструкцию:
```
override переменная += добавляемый-текст
```

---
<a name="many_string_variables"><h2>Многострочные переменные</h2></a>

### Использование директивы define

С ее помощью удобно определять именованные командные последовательности

На первой строке находится только название директивы (`define`), за которым следует имя переменной. Значение переменной указывается в следующих строках. Меткой конца значения переменной служит строка, содержащая единственное слово `endef`.

```
define two-lines
echo foo
echo $(bar)
endef
```
При использовании обычного оператора присваивания, значение переменной не может содержать символов перевода строки. При использовании же директивы `define`, символы перевода строки (за исключением символа, находящегося перед строкой с `endef`) становятся частью значения переменной.

Предыдущий пример функционально подобен:
```
two-lines = echo foo; echo $(bar)
```
> Поскольку две команды, разделенные точкой с запятой работают во многом также, как и две отдельные команды. Заметьте, однако, что для команд, расположенных в двух отдельных строках, make будет вызывать командный интерпретатор дважды, запуская каждую команду в своей отдельной копии интерпретатора. 

---

<a name="variables_environment"><h2>Переменные из операционного окружения (environment)</h2></a>

Переменные в make могут "приходить" из программного окружения (environment), в котором make была запущена. Каждая переменная среды (environment variable), видимая для `make`, преобразуется в соответствующую переменную make с таким же именем и значением.

Однако, явное определение такой же переменной внутри make-файла или через командную строку, "перекроет" значение, полученное из операционной среды. (При наличии опции `-e`, значения из переменных среды будут иметь "приоритет" перед значениями, определенными в make-файле. Смотрите раздел Обзор опций. Но мы не рекомендуем использовать такую практику.)

---

<a name="if_parts_makefile"><h2>Условные части make-файла</h2></a>

```
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif
```
В этой условной конструкции используется три директивы: `ifeq`, `else` и `endif`.

Директива `ifeq` определяет начало условной конструкции и указывает само условие. Она имеет два параметра, разделенных запятой и заключенных в скобки. Эти параметры вычисляются и, затем, сравниваются. Если два параметра совпадают, строки, следующие за `ifeq`, обрабатываются; в противном случае они игнорируются.

При использовании директивы `else`, следующие за ней строки должны быть обработаны, если условие (из директивы `ifeq`) не выполняется. В предыдущем примере, это означает использование второй, альтернативной команды компоновки, если первая альтернатива не будет использована. Наличие директивы `else` в условной конструкции не является обязательным.

Директива `endif` завершает условную конструкцию. Следующие за этой директивой строки, относятся уже к "безусловной" части make-файла. Наличие директивы endif является обязательным.

---

<a name="function_foreach"><h2>Функция foreach</h2></a>

Синтаксис функции foreach выглядит следующим образом:
```
$(foreach переменная,список,текст)
```


Функция if
```
$(if условие,фрагмент-для-выполненного-условия[,фрагмент-для-невыполненного-условия])
```


`-n`
`--just-print`
`--dry-run`
`--recon`
Будут печататься (без реального выполнения) команды, которые бы выполнила make для обновления целей.

---
<a name="overriding"><h2>Перекрытие" (overriding) переменных</h2></a>

Аргумент командной строки, содержащий `=` определяет значение переменной: запись `v=x` означает, что переменная `v` получит значение `x`. Если значение переменной было задано подобным образом, то все "обычные" присваивания этой переменной нового значения внутри make-файла будут игнорироваться; мы говорим что они будут перекрыты (overridden) аргументом командной строки.

---
<a name="optionns"><h2>Обзор опций</h2></a>

Вот полный список опций, распознаваемых программой make:

`-C каталог`  
`--directory=каталог`  
Перед чтением make-файла перейти в каталог каталог. При наличии сразу нескольких опций `-C`, каждая из них рассматривается относительно предыдущей: так, `-C / -C etc` эквивалентно `-C /etc`. 

Обычно, это используется при рекурсивном вызове make (смотрите раздел Рекурсивный вызов make).

--- 
`-d`  
В дополнение к основной работе, выводить отладочную информацию. Отладочная информация содержит в себе много интересного: 

например, какие файлы make считает необходимым обновить, для каких файлов сравнивается их время изменения и каков полученный результат, какие неявные правила рассматриваются в качестве кандидатов на исполнение и какие из них действительно выполняются и так далее. Опция -d эквивалентна использованию опции `--debug=a` (смотрите ниже).
`--debug[=опции]`  

В дополнение к основной работе, выводить отладочную информацию. При выводе отладочной информации можно выбрать нужный ее тип и степень "подробности". 

При отсутствии аргументов, выбирается "базовый" уровень отладочной информации. Ниже перечислены все возможные аргументы; при "разборе" аргументов учитывается только первый символ названия. 

При задании нескольких аргументов, они должны разделяться пробелами или запятыми.  
- `a` (all)
Выдача всей имеющейся отладочной информации ("максимальный уровень"). Эквивалентно использованию опции `-d`.  
- `b` (basic)
"Базовый уровень" отладочной информации: печатаются все цели, которые были найдены "устаревшими" и информация об успешности или неуспешности попытки их обновления.
- `v` (verbose)
Следующий уровень после "базового"; дополнительно выдается информация о том, какие make-файлы обрабатываются, какие пререквизиты не нуждаются в обновлении и так далее. Включение этой опции также приводит к выдаче отладочной информации "базового" уровня.
- `i` (implicit)
Выдается информация о процессе поиска подходящих неявных правил для каждой из целей. Включение этой опции также приводит к выдаче отладочной информации "базового" уровня.
- `j` (jobs)
Выдача информации о вызове некоторых команд.
- `m` (makefile)

>По умолчанию, описанная выше отладочная информация не выдается на стадии, когда make пробует обновить make-файлы. Данная опция разрешает выдачу отладочной информации в процессе обновления make-файлов. Обратите внимание, что `all` также включает данную опцию. Эта опция также разрешает выдачу отладочных сообщений "базового" уровня.
---
`-e`  
`--environment-overrides`  
Дает переменным, созданным из соответствующих переменных среды "приоритет" перед переменными, определенными внутри make-файла. 
---
`-f файл`  
`--file=файл`  
`--makefile=файл`  
Указанный файл рассматривается в качестве make-файла. 
---
`-h`  
`--help`  
Напоминает вам список опций, распознаваемых make и завершает работу.
---
`-i`  
`--ignore-errors`  
Игнорировать все ошибки, возникающие в любых командах, исполняемых для обновления файлов. 
---
`-I каталог`  
`--include-dir=каталог`  
Указывает каталог для поиска включаемых make-файлов. При наличии нескольких опций `-I`, поиск в указанных каталогах производится в том порядке, как они были перечислены.
---
`-j [число_заданий]`  
`--jobs[=число_заданий]`  
Указывает количество одновременно выполняемых заданий (команд). При отсутствии аргумента, число одновременно выполняемых заданий не ограничено. При наличии сразу нескольких опций `-j`, будет действовать только последняя из перечисленных. Обратите внимание, что при работе в операционной системе MS-DOS, эта опция игнорируется.
---
`-k`  
`--keep-going`  
После возникновения ошибки, продолжить, насколько это возможно, обработку make-файла. Хотя цель, при обновлении которой произошла ошибка, уже не сможет быть корректно обновлена, и, следовательно, не могут быть правильно обновлены и все цели, зависящие от нее, make попробует обработать другие пререквизиты этих целей.
---
`-l [загрузка]`  
`--load-average[=загрузка]`  
`--max-load[=загрузка]`  
Указывает, что новые задания (команды) не должны запускаться если уже имеется хотя бы одно запущенная задание и загрузка системы равна или превышает значение загрузка (число с плавающей точкой). При отсутствии аргумента, ограничение на максимальную загрузку снимается. 
---
`-n`  
`--just-print`  
`--dry-run`  
`--recon`  
Печатать команды, которые должны выполняться, но не исполнять их.
---
`-o файл`  
`--old-file=файл`  
`--assume-old=файл`
Не обновлять файл даже если он "старше" своих пререквизитов и при обработке других файлов не принимать в рассчет возможные изменения в этом файле. По существу, этот файл обрабатывается как "очень старый" и его правила игнорируются. 
---
`-p`  
`--print-data-base`
Перед началом основной работы, распечатать базу данных (правила и значения переменных), полученную в результате чтения make-файла. Печатается также информация о номере версии (аналогично опции `-v`, смотрите ниже). Для того, чтобы просто распечатать базу данных, не обновляя при этом никаких файлов, используйте `make -qp`. Для распечатки базы данных с предопределенными правилами и переменными, используйте `make -p -f /dev/null`. Помимо всего прочего, выводимая информация содержит имя файла и номер строки, где было дано определение правила или переменной. Это может оказаться ценным подспорьем для отладки сложных make-файлов.
---
`-q`
`--question`
"Режим проверки". Никаких команд не выполняется и не печатается никаких сообщений. Вся работа make заключается в возврате соответствующего кода завершения. В случае, если указанная цель не нуждается в обновлении, возвращается нулевой код. В случае, если обновление требуется, возвращается код, равный единице. При возникновении каких-либо ошибок ошибок, возвращается код, равный двум.
---
`-r`
`--no-builtin-rules`
Отключает использование встроенных неявных правил (смотрите раздел Использование неявных правил). Однако, вы по-прежнему можете задать свои собственные неявные правила с помощью шаблонных правил (смотрите раздел Определение и переопределение шаблонных правил). Опция `-r` также очищает используемый по умолчанию список суффиксов для суффиксных правил. (смотрите раздел Устаревшие суффиксные правила). По-прежнему, вы можете использовать специальную цель `.SUFFIXES` для определения своего собственного списка суффиксов. Далее, эти суффиксы можно будет использовать в своих суффиксных правилах. Обратите внимание, что опция `-r` воздействует только на правила и никак не влияет на используемые по умолчанию переменные
---
`-R`
`--no-builtin-variables`
Отключает использование встроенных переменных, используемых неявными правилами (смотрите раздел Используемые в неявных правилах переменные). Разумеется, вы по-прежнему можете определять свои собственные переменные. Включение опции `-R` автоматически приводит к включению опции `-r`, поскольку нет смысла в наличии неявных правил без наличия переменных, которые в них используются.
---
`-s`
`--silent`
`--quiet`
"Бесшумный режим". Отключается печать исполняемых команд. 
---
`-S`
`--no-keep-going`
`--stop`
Отменяет опцию `-k`. Как правило, это может потребоваться только при рекурсивном использовании make, когда опция `-k` может быть "унаследована" через переменную `MAKEFLAGS` от `make` "верхнего уровня" или в случае, если эта опция была установлена через переменную среду `MAKEFLAGS`.
---
`-t`
`--touch`
Не выполняя команд, просто обновляет время последней модефикации файлов (в действительности не изменяя их). Таким образом, make "делает вид" что все необходимые команды были выполнены, дабы "обмануть" последующие запуски make. 
---
`-v`
`--version`
Выдает информацию о версии программы make, ее авторах, авторских правах, замечание об отсутствии гарантий и завершает работу.
---
`-w`
`--print-directory`
Печатать сообщение с именем текущего каталога до и после обработки make-файла. Это может оказаться полезным при поиске нетривиальных ошибок, связанных с рекурсивным вызовом make. Смотрите раздел Рекурсивный вызов make. (На практике, вам редко когда понадобится указывать эту опцию, поскольку, во многих случаях, make включает ее автоматически; смотрите раздел Опция `--print-directory`.)
---
`--no-print-directory`
Отменить печать рабочего каталога (опции -w). Эта опция может оказаться полезной в тех случаях, когда make автоматически включает опцию -w, а вы не хотели бы получать дополнительные сообщения.
---
`-W файл`
`--what-if=файл`
`--new-file=файл`
`--assume-new=файл`
"Притвориться", что цель файл только что была модефицирована. Будучи использована совместно с опцией `-n`, покажет, какие действия будут выполнены если этот файл действительно будет модефицирован. Без опции `-n`, эффект сходен с выполнением команды touch для указанного файла с последующим запуском make, за исключеним того, что время последней модефикации этого файла происходит только в "воображении" make. 
---
`--warn-undefined-variables`
Когда make будет встречать ссылки на неопределенные переменные, будут выдаваться соответствующие предупреждающие сообщения. Это может оказаться полезным при отладке make-файлов, в которых переменные используются нетривиальным образом.
